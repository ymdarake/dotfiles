# Go プロジェクトガイドライン

Goプロジェクト用の詳細な開発ガイドラインです。

## 技術スタック

- **言語**: Go
- **フレームワーク**: (例: Echo, Gin, Chi, gRPC など)
- **その他**: (例: PostgreSQL, Redis, Docker など)

## Bashコマンド

```bash
go build ./...         # プロジェクト全体をビルド
go test ./...          # 全テストを実行
go test -v ./...       # 詳細出力でテスト実行
go test -cover ./...   # カバレッジ付きでテスト実行
go run main.go         # メインを実行
go mod tidy            # 依存関係を整理
go fmt ./...           # コードフォーマット
go vet ./...           # 静的解析
golangci-lint run      # Lintを実行（インストール済みの場合）
```

## プロジェクト構成

```
cmd/                    # エントリーポイント（main.go）
internal/               # 内部パッケージ
pkg/                    # 外部公開パッケージ
api/                    # API定義
test/                   # 統合テスト
go.mod                  # モジュール定義
```

## コーディングスタイル

- `gofmt` でフォーマット済み
- パッケージ名: 小文字、単一単語
- インターフェース名: `~er` で終わる（Reader, Writer など）
- エクスポート: 大文字開始（Public）、小文字開始（private）
- エラーハンドリング: 明示的に処理、`panic` は避ける
- コメント: エクスポートされた関数・型には必ずコメント

## アーキテクチャ指針（Go）

- 目的: Handler（入出力）からデータ操作を分離しテスト容易性を向上。保存方法（DB/FS/HTTP/Memory）の差し替えを容易に。
- レイヤ構成:
  - Interface Adapter（HTTP/CLI 等）
    - ↓ Application（UseCase）
      - ↓ Domain（Repository 抽象/Entity/Value）
        - ↓ Infrastructure（具体: DB/FS/HTTP/Memory）
- Composition Root（起動点）で具体 Repository と Clock 等の依存を生成・注入。
- Contract Test（抽象に対する InMemory/実装の同一性）→ UseCase Test（Clock 固定）→ Handler テストの順で担保。

### ディレクトリ構造（例）

```
cmd/app/                        # エントリポイント（main）
internal/
  interface/                   # ハンドラ/CLI等の入出力境界
    http/
      handler.go
    cli/
      command.go
  application/                 # UseCase
    usecase/
      save_score.go
      load_rankings.go
  domain/                      # 抽象・モデル
    ranking/
      entity.go
      repository.go           # interface RankingRepository
      types.go
  infrastructure/              # 具体実装
    ranking/
      memory/
        repository.go
      file/
        repository.go
      db/
        repository.go
shared/
  clock/
    clock.go
```

## Go 固有のベストプラクティス

### エラーハンドリング

```go
// エラーのラップ
if err != nil {
    return fmt.Errorf("failed to process: %w", err)
}

// カスタムエラー型を定義
type MyError struct {
    Code    int
    Message string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("error %d: %s", e.Code, e.Message)
}
```

### インターフェース設計

```go
// 小さなインターフェースを推奨
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

// 組み合わせて使用
type ReadWriter interface {
    Reader
    Writer
}
```

### 並行処理

```go
// Goroutine の適切な使用
func processData(data []Data) error {
    var wg sync.WaitGroup
    errChan := make(chan error, len(data))
    
    for _, item := range data {
        wg.Add(1)
        go func(d Data) {
            defer wg.Done()
            if err := processItem(d); err != nil {
                errChan <- err
            }
        }(item)
    }
    
    wg.Wait()
    close(errChan)
    
    for err := range errChan {
        if err != nil {
            return err
        }
    }
    
    return nil
}
```

### Context の使用

```go
// Context でキャンセレーションとタイムアウトを管理
func fetchData(ctx context.Context, url string) ([]byte, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    client := &http.Client{
        Timeout: 30 * time.Second,
    }
    
    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    return io.ReadAll(resp.Body)
}
```

## テスト方針

- テストファイル: `*_test.go`
- テーブル駆動テスト推奨
- モックは `interface` で定義
- カバレッジ80%以上を目標

### テストの書き方

```go
func TestCalculate(t *testing.T) {
    tests := []struct {
        name     string
        input    int
        expected int
    }{
        {"positive number", 5, 25},
        {"zero", 0, 0},
        {"negative number", -3, 9},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Calculate(tt.input)
            if result != tt.expected {
                t.Errorf("Calculate(%d) = %d, want %d", tt.input, result, tt.expected)
            }
        })
    }
}
```

### モックの実装

```go
// インターフェースを定義
type Repository interface {
    Save(data Data) error
    Find(id string) (*Data, error)
}

// モック実装
type MockRepository struct {
    data map[string]Data
}

func NewMockRepository() *MockRepository {
    return &MockRepository{
        data: make(map[string]Data),
    }
}

func (m *MockRepository) Save(data Data) error {
    m.data[data.ID] = data
    return nil
}

func (m *MockRepository) Find(id string) (*Data, error) {
    if data, exists := m.data[id]; exists {
        return &data, nil
    }
    return nil, errors.New("not found")
}
```

## 依存管理

- Go modules を使用
- 外部依存は最小限に
- `go mod tidy` で不要な依存を削除

### go.mod の例

```go
module github.com/example/project

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/lib/pq v1.10.9
)

require (
    // 間接依存
)
```

## パフォーマンス

### メモリ効率

```go
// スライスの事前割り当て
func processItems(items []Item) []Result {
    results := make([]Result, 0, len(items)) // 容量を事前に確保
    for _, item := range items {
        results = append(results, processItem(item))
    }
    return results
}

// 文字列の効率的な結合
func buildQuery(parts []string) string {
    var builder strings.Builder
    builder.Grow(len(parts) * 10) // 適切な容量を確保
    for i, part := range parts {
        if i > 0 {
            builder.WriteString(" AND ")
        }
        builder.WriteString(part)
    }
    return builder.String()
}
```

### プロファイリング

```go
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // アプリケーションのメインロジック
}
```

## セキュリティ

- SQLインジェクション対策（プレースホルダー使用）
- 入力値の検証
- 認証・認可の実装
- HTTPSの使用

```go
// SQLインジェクション対策
func getUserByID(db *sql.DB, id string) (*User, error) {
    query := "SELECT id, name, email FROM users WHERE id = $1"
    row := db.QueryRow(query, id) // プレースホルダーを使用
    
    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Email)
    if err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

## ログとモニタリング

```go
import "log/slog"

func main() {
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    slog.SetDefault(logger)
    
    slog.Info("application started", "version", "1.0.0")
}

func processRequest(req *Request) error {
    slog.Info("processing request", 
        "request_id", req.ID,
        "user_id", req.UserID,
    )
    
    // 処理ロジック
    
    slog.Info("request processed successfully", "request_id", req.ID)
    return nil
}
```

---

*参考: [Go公式ドキュメント](https://golang.org/doc/), [Effective Go](https://golang.org/doc/effective_go.html)*