# Terraform プロジェクトガイドライン

Terraformプロジェクト用の詳細な開発ガイドラインです。

## 技術スタック

- **IaC**: Terraform
- **クラウドプロバイダー**: (例: AWS, GCP, Azure など)
- **その他**: (例: バックエンドストレージ、CI/CDツール など)

## Bashコマンド

```bash
terraform init             # 初期化（プロバイダーダウンロード）
terraform plan             # 実行計画を確認
terraform apply            # インフラをプロビジョニング
terraform apply -auto-approve  # 確認なしで適用
terraform destroy          # リソースを削除
terraform fmt              # コードフォーマット
terraform validate         # 構文チェック
terraform state list       # 管理中のリソース一覧
terraform state show <resource>  # リソース詳細表示
terraform output           # Output変数を表示
terraform workspace list   # ワークスペース一覧
terraform workspace select <name>  # ワークスペース切り替え
```

## 環境ごとの実行方法（Workspace使用）

```bash
# ワークスペース作成
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

# 開発環境で実行
terraform workspace select dev
terraform plan -var-file="environments/dev.tfvars"
terraform apply -var-file="environments/dev.tfvars"

# ステージング環境で実行
terraform workspace select staging
terraform plan -var-file="environments/staging.tfvars"
terraform apply -var-file="environments/staging.tfvars"

# 本番環境で実行
terraform workspace select prod
terraform plan -var-file="environments/prod.tfvars"
terraform apply -var-file="environments/prod.tfvars"
```

## プロジェクト構成

```
.
├── main.tf           # メインの設定
├── variables.tf      # 変数定義
├── outputs.tf        # Output定義
├── versions.tf       # Terraformバージョン・プロバイダー定義
├── terraform.tfvars  # デフォルトの変数値
├── backend.tf        # バックエンド設定（S3等）
├── modules/          # 再利用可能なモジュール
│   ├── app/                    # 意味単位（アプリケーションドメイン）
│   │   ├── api-gateway/
│   │   ├── data-processing/
│   │   └── monitoring/
│   ├── platform/              # 全サービス横断の標準基盤（ネットワーク/IAM/監査/可観測性など）
│   │   ├── networking/
│   │   ├── security/
│   │   └── observability/
│   └── components/            # 機能単位（下位の汎用部品）
│       ├── database/
│       ├── queue/
│       └── compute/
└── environments/              # 環境ごとの変数ファイル
    ├── dev.tfvars
    ├── staging.tfvars
    └── prod.tfvars
```

## コーディングスタイル

- リソース名: snake_case
- 変数名: snake_case
- モジュール名: kebab-case
- インデント: スペース2つ
- `terraform fmt` でフォーマット必須
- 1ファイルは300行以内を目安

## ベストプラクティス

### State管理

#### 推奨構成（専用プロジェクト方式）

```
terraform-state-project (独立・State管理専用)
├── terraform-state-bucket
│   ├── app-project-dev/
│   ├── app-project-staging/
│   └── app-project-prod/

app-project (独立・アプリケーション専用)
├── dev/
├── staging/
└── prod/
```

**関係性**: app-projectのStateファイルをterraform-state-projectのバケットに保存

#### backend.tf 設定例

```hcl
terraform {
  backend "gcs" {
    bucket = "terraform-state-bucket"
    prefix = "app-project"
  }
}
```

#### メリット

- **セキュリティ**: Stateとリソースを分離
- **権限管理**: State管理専用のIAM設定
- **災害復旧**: Stateの独立バックアップ
- **監査**: State操作の独立ログ

#### IAM設定例

```yaml
# State管理プロジェクト
terraform-state-project:
  - roles/storage.objectAdmin (State管理用)
  
# 本番プロジェクト  
app-project:
  - roles/compute.admin (リソース管理用)
  - roles/storage.objectViewer (State読み取り用)
```

#### バケットの推奨設定（GCS）

バージョニングやアクセス制御を有効化し、Stateの安全性を高める。

```bash
# バージョニングを有効化（履歴保持）
gsutil versioning set on gs://terraform-state-bucket

# Retention Policy（必要に応じて）
gsutil retention set 30d gs://terraform-state-bucket

# バケットレベルの一元アクセス制御
gsutil uniformbucketlevelaccess set on gs://terraform-state-bucket

# 必要に応じてCMEKを使用（コンプライアンス要件等）
# KMSキー作成と関連付けは組織の規約に従う
```

#### バージョン固定（Pinning）

Terraform本体・プロバイダーのバージョンを固定し、再現性を担保する。

```hcl
terraform {
  required_version = "~> 1.8.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}
```

#### 権限設計（IAM）

- 最小権限の原則（Principle of Least Privilege）を遵守。
- CI用Service AccountにはState操作と必要リソース操作のみを付与。
- prefix単位の厳格な分離が必要な場合は、アプリごとにバケット分割も検討。

例（方針の一例、実際の権限は組織基準に従う）:

```yaml
# State管理プロジェクト（最小限）
terraform-state-project:
  - roles/storage.objectAdmin  # State操作用（必要に応じて更に絞る）

# 本番プロジェクト（リソース操作に必要な最小権限）
app-project:
  - roles/compute.admin
  - roles/storage.objectViewer # State読み取りが必要な場合のみ
```

#### 併走制御（Concurrency）

- applyはCIで直列実行（環境・ディレクトリごとにジョブを直列化）。
- PRでは `terraform plan -detailed-exitcode` を使用し、差分有無でゲート。

#### セキュリティ / 運用

- tfvarsに秘密情報を含めない。Secret ManagerやCIの変数管理を使用。
- 静的解析の導入を推奨（tflint, tfsec, trivy など）。
- 自動フォーマット（terraform fmt）とvalidateをCIに組み込み。

### 変数定義

```hcl
variable "environment" {
  description = "環境名（dev, staging, prod）"
  type        = string
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "環境名はdev, staging, prodのいずれかである必要があります"
  }
}

variable "instance_count" {
  description = "インスタンス数"
  type        = number
  default     = 1
  validation {
    condition     = var.instance_count > 0
    error_message = "インスタンス数は1以上である必要があります"
  }
}
```

### リソースの命名規則

```hcl
resource "aws_instance" "web_server" {
  # ${環境}_${用途}_${リソース種別}
  tags = {
    Name        = "${var.environment}-web-server"
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "terraform"
  }
}
```

### モジュール化

- 再利用可能な構成はモジュール化
- モジュールには README.md を用意
- Input/Output を明確に定義
- ディレクトリは「意味単位」で整理（networking/compute/database/security/observability など）。
  単一リソース名（vpc/ec2/rds）の粒度ではなく、ドメイン機能でまとめる。

#### モジュール階層（意味 → 機能）

意味単位の上位モジュール（例: `modules/networking`）から、機能単位の下位モジュール（例: `modules/feature/vpc`, `modules/feature/subnets`, `modules/feature/nat` など）を合成します。上位は意図・命名・ポリシーを一元適用し、必要最小限の出力だけを再エクスポートします。

ディレクトリ例:

```
modules/
  networking/           # 意味単位（上位）
    main.tf
    variables.tf
    outputs.tf
  feature/              # 機能単位（下位）
    vpc/
      main.tf
      variables.tf
      outputs.tf
    subnets/
      main.tf
      variables.tf
      outputs.tf
    nat/
      main.tf
      variables.tf
      outputs.tf
```

上位から下位を参照する例（抜粋）:

```hcl
# modules/networking/main.tf
variable "environment" { type = string }
variable "vpc_cidr"    { type = string }

module "vpc" {
  source   = "../feature/vpc"
  name     = "${var.environment}-vpc"
  vpc_cidr = var.vpc_cidr
}

module "subnets" {
  source    = "../feature/subnets"
  vpc_id    = module.vpc.vpc_id
  cidrs     = ["10.0.1.0/24", "10.0.2.0/24"]
  az_suffix = ["a", "c"]
}

module "nat" {
  source            = "../feature/nat"
  vpc_id            = module.vpc.vpc_id
  public_subnet_ids = module.subnets.public_subnet_ids
}

output "vpc_id"            { value = module.vpc.vpc_id }
output "public_subnet_ids" { value = module.subnets.public_subnet_ids }
```

#### ユーティリティリポジトリへの切り出し（推奨）

`modules/components` などの汎用モジュールは、コードが安定したら**独立リポジトリ**として管理し、各プロジェクトから参照します。

- 配布方法:
  - Terraform Registry（社内/外）に公開、または
  - Gitリポジトリを `source` に指定（タグ固定）
- バージョニング: セマンティックバージョニング（MAJOR.MINOR.PATCH）
- 参照側: バージョン（またはGitタグ/コミット）を必ず固定
- CI: 変更時に自動テスト・`terraform validate` を実行し、タグ切り/リリースノートを自動化

例（Gitリポジトリ参照・タグ固定）:

```hcl
module "queue" {
  source  = "git::https://github.com/your-org/tf-mod-queue.git?ref=v1.4.2"
  name    = "${var.environment}-queue"
  project = var.project
}
```

例（Registry参照・バージョン固定）:

```hcl
module "database" {
  source  = "your-org/database/google"
  version = "~> 2.3"
  name    = "${var.environment}-db"
}
```

#### モジュール例

```hcl
# modules/networking/main.tf
variable "vpc_cidr" {
  description = "VPCのCIDRブロック"
  type        = string
}

variable "environment" {
  description = "環境名"
  type        = string
}

resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "${var.environment}-vpc"
    Environment = var.environment
  }
}

output "vpc_id" {
  description = "VPCのID"
  value       = aws_vpc.main.id
}

output "vpc_cidr_block" {
  description = "VPCのCIDRブロック"
  value       = aws_vpc.main.cidr_block
}
```

#### モジュールの使用

```hcl
# main.tf
module "networking" {
  source = "./modules/networking"

  vpc_cidr    = "10.0.0.0/16"
  environment = var.environment
}

resource "aws_subnet" "public" {
  vpc_id     = module.networking.vpc_id
  cidr_block = "10.0.1.0/24"
  # ...
}
```

## セキュリティ

- **秘密情報をコードに直接書かない**
- 認証情報は環境変数または AWS/GCP の認証機構を使用
- `.tfvars` ファイルは `.gitignore` に追加
- `terraform.tfstate` は Git にコミットしない（リモートバックエンド使用）
- センシティブな変数には `sensitive = true` を設定

```hcl
variable "db_password" {
  description = "データベースパスワード"
  type        = string
  sensitive   = true
}

resource "aws_db_instance" "main" {
  # ...
  password = var.db_password
}

output "db_endpoint" {
  description = "データベースエンドポイント"
  value       = aws_db_instance.main.endpoint
  sensitive   = true
}
```

## State管理

- リモートバックエンド（S3 + DynamoDB）を使用
- State ロックを有効化
- 環境ごとにワークスペースまたは別バックエンドを使用

### バックエンド設定例

```hcl
# backend.tf
terraform {
  backend "s3" {
    bucket         = "my-terraform-state-bucket"
    key            = "terraform.tfstate"
    region         = "ap-northeast-1"
    dynamodb_table = "terraform-state-lock"
    encrypt        = true
  }
}
```

### ワークスペースの使用

```bash
# 環境ごとのワークスペース作成
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

# ワークスペース切り替え
terraform workspace select dev

# 現在のワークスペース確認
terraform workspace show
```

## テスト・検証

- `terraform plan` で変更内容を必ず確認
- `terraform validate` で構文チェック
- Terratest や kitchen-terraform でテスト（推奨）
- Checkov / tfsec でセキュリティスキャン

### Terratest の例

```go
package test

import (
    "testing"
    "github.com/gruntwork-io/terratest/modules/terraform"
    "github.com/stretchr/testify/assert"
)

func TestTerraformAwsExample(t *testing.T) {
    terraformOptions := &terraform.Options{
        TerraformDir: "../",
        VarFiles:     []string{"terraform.tfvars"},
    }

    defer terraform.Destroy(t, terraformOptions)
    terraform.InitAndApply(t, terraformOptions)

    instanceId := terraform.Output(t, terraformOptions, "instance_id")
    assert.NotEmpty(t, instanceId)
}
```

## 環境管理

### 環境ごとの設定

```hcl
# environments/dev/terraform.tfvars
environment = "dev"
instance_count = 1
instance_type = "t3.micro"

# environments/prod/terraform.tfvars
environment = "prod"
instance_count = 3
instance_type = "t3.large"
```

### 環境固有のリソース

```hcl
# 環境によって異なるリソースを作成
resource "aws_instance" "web" {
  count = var.environment == "prod" ? 3 : 1
  
  ami           = var.ami_id
  instance_type = var.instance_type
  
  tags = {
    Name        = "${var.environment}-web-${count.index + 1}"
    Environment = var.environment
  }
}
```

## データソースの活用

```hcl
# 既存のリソースを参照
data "aws_vpc" "existing" {
  filter {
    name   = "tag:Name"
    values = ["existing-vpc"]
  }
}

data "aws_subnets" "existing" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.existing.id]
  }
}

resource "aws_instance" "web" {
  subnet_id = data.aws_subnets.existing.ids[0]
  # ...
}
```

## 条件分岐とループ

### 条件分岐

```hcl
resource "aws_instance" "web" {
  count = var.create_instance ? 1 : 0
  
  ami           = var.ami_id
  instance_type = var.instance_type
  
  tags = {
    Name = var.create_instance ? "web-server" : "disabled"
  }
}
```

### ループ

```hcl
variable "subnet_cidrs" {
  description = "サブネットのCIDRブロック"
  type        = list(string)
  default     = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
}

resource "aws_subnet" "private" {
  count = length(var.subnet_cidrs)
  
  vpc_id     = aws_vpc.main.id
  cidr_block = var.subnet_cidrs[count.index]
  
  tags = {
    Name = "private-subnet-${count.index + 1}"
  }
}
```

## エラーハンドリングと検証

```hcl
variable "port" {
  description = "ポート番号"
  type        = number
  default     = 80
  
  validation {
    condition     = var.port > 0 && var.port <= 65535
    error_message = "ポート番号は1-65535の範囲である必要があります"
  }
}

resource "aws_security_group" "web" {
  name_prefix = "web-"
  
  ingress {
    from_port   = var.port
    to_port     = var.port
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```

## Git運用

- `terraform apply` 前に必ず `plan` を確認
- 本番環境への適用は慎重に
- PR には `terraform plan` の出力を添付
- インフラ変更は小さく頻繁に

### CI/CD パイプライン例

```yaml
# .github/workflows/terraform.yml
name: Terraform
on:
  pull_request:
    paths:
      - 'terraform/**'

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
      - name: Terraform Format Check
        run: terraform fmt -check
      - name: Terraform Init
        run: terraform init
      - name: Terraform Validate
        run: terraform validate
      - name: Terraform Plan
        run: terraform plan
```

---

*参考: [Terraform公式ドキュメント](https://www.terraform.io/docs/), [Terraform Best Practices](https://www.terraform-best-practices.com/)*