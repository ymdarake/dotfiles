# Mermaid 図作成ガイドライン

一般的な実例に基づく、Mermaid記法のガイドライン。

## ノードラベルと形状
- 括弧/記号/空白を含むラベルは二重引用符で囲む
  - 例: `CF["collector-function (Cloud Functions Python)"]`
- ラベル内の改行は使わず、半角スペースに置換（`\n` は文字通り表示される場合がある）
  - NG: `GCS[("Cloud Storage\nraw-data")]`
  - OK: `GCS[("Cloud Storage raw-data")]`
- 形状指定はラベル外側（`[]`, `()`, `(())`, `{}`）で、ラベル中の括弧はクォートで許容
  - 例: `FS[("Firestore user_feeds / dedup_keys")]`

## サブグラフ/スタイル
- `subgraph` でレイヤ/領域（Ingest/Data/Analyze/API/Client 等）を明確化
- スタイル（`classDef`）は詳細ドキュメントで、README の簡易図では最小限に

## エッジと記号
- 通常フローは `-->`、補助/参照は `-.->` を使い分ける
- テキスト付きエッジは最小限（詳細は表や注釈へ）

## シーケンス図（sequenceDiagram）
- `participant` は短名＋ラベル（`participant APP as application-service`）
- メッセージは動詞から（例: `APP->>DB: レコード作成`）
- 任意/本番のみ等は注釈で明記

### 典型例（基本フロー）
```mermaid
%%{init:{'theme':'base','themeVariables':{'textColor':'#111111','lineColor':'#333333','fontSize':'16px'}}}%%
sequenceDiagram
  box LemonChiffon Client
    participant CL as client
  end
  box AliceBlue Server
    participant API as api-gateway
    participant APP as application-service
  end
  box HoneyDew Data
    participant DB as database
  end
  box LavenderBlush External Services
    participant EXT as external-service
  end

  CL->>API: リクエスト送信（JSON）
  API->>APP: リクエスト委譲
  APP->>DB: レコード検索
  DB-->>APP: 検索結果
  APP->>EXT: 外部API呼び出し（必要時）
  EXT-->>APP: 外部API応答
  APP-->>API: 正常レスポンス（200, JSON）
  API-->>CL: 応答返却

  Note over APP,DB: トランザクションは最小範囲で
  opt リトライ
    APP->>EXT: 再試行（指数バックオフ）
  end
```

## 典型例（簡易構成図）
```mermaid
graph LR
  %% スタイル定義（このブロック内でも使用できるよう最小限を同梱）
  classDef layerApp fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,fill-opacity:0.35
  classDef layerData fill:#f1f8e9,stroke:#388e3c,stroke-width:2px,fill-opacity:0.35
  classDef layerCompute fill:#ede7f6,stroke:#5e35b1,stroke-width:2px,fill-opacity:0.35
  classDef layerSecurity fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,fill-opacity:0.35
  classDef nodeClient fill:#fffde7,stroke:#fbc02d,stroke-width:2px,fill-opacity:0.35

  subgraph System[System]
    subgraph ClientZone[Client]
      CL[Client]
    end

    subgraph ApplicationLayer[Application Layer]
      API[API Gateway]
      APP[Application Service]
    end

    subgraph DataLayer[Data Layer]
      DB[(Database)]
      OBJ[(Object Storage)]
    end

    subgraph ComputeLayer[Compute Layer]
      Q[Message Queue]
      WK[Background Worker]
      BUS[Event Bus]
    end

    subgraph SecurityLayer[Security]
      SEC[Policy/Guard]
    end
  end

  %% レイヤ別スタイル適用
  class CL nodeClient
  class API,APP layerApp
  class DB,OBJ layerData
  class Q,WK,BUS layerCompute
  class SEC layerSecurity

  %% フロー
  CL --> API --> APP
  APP --> DB
  APP --> OBJ
  APP -.-> BUS
  APP --> Q
  Q --> WK
  WK --> DB
  BUS --> APP

  %% サブグラフ背景色（レイヤごとの背景）
  style ClientZone fill:#fffde7,stroke:#fbc02d,stroke-width:2px,fill-opacity:0.15
  style ApplicationLayer fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,fill-opacity:0.15
  style DataLayer fill:#f1f8e9,stroke:#388e3c,stroke-width:2px,fill-opacity:0.15
  style ComputeLayer fill:#ede7f6,stroke:#5e35b1,stroke-width:2px,fill-opacity:0.15
  style SecurityLayer fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,fill-opacity:0.15
```

## トラブルシュート（パースエラー）
- 例: `Expecting 'SQE' ... got 'PS'`
  - 未クォートの括弧付きラベル / ラベル内改行 / 括弧不一致が原因になりやすい
- 対処: ラベルをクォート、改行→スペース、対応括弧を見直す


## 実務ルール（要約）

- クラス定義の同梱: 例示用コードブロック内に、使用する `classDef` を最小限再掲する。
- 役割ベース命名: ノードは役割（Client/API/Application/Data/Compute/Security）で命名する。
- サブグラフ分割: レイヤ単位で `subgraph` を分割し、読みやすさと責務境界を明確化する。
- サブグラフ背景: `style <subgraphId> fill:...,stroke:...,fill-opacity:...` で背景色を付与する。
- クラス適用順序: ノード定義→（必要なら）サブグラフ→`class` 適用→エッジ定義の順を基本とする。
- エッジ記法: 通常は `-->`、補助/参照は `-.->` を使い分け、説明の文章は最小限に。
- ラベルのクォート: 括弧/記号/空白を含むラベルは二重引用符で囲む。ラベル内改行は使わない。
