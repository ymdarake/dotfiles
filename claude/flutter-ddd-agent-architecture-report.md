# Flutter DDD × AIエージェント構成 調査レポート

## 1. 現状構成の評価

### 1.1 DDD Architectエージェント

DDDアーキテクトエージェントは、AIコーディング環境において「アーキテクチャの意図」を維持する役割を担っている。ドメインエンティティ、バリューオブジェクト、アグリゲート、バウンデッドコンテキストを仕様として符号化することで、生成コードが依存性逆転の原則（ドメイン層は純粋Dart、Flutterインポート不可）、適切なレイヤー分離（Presentation → Application → Domain → Infrastructure）、一貫した命名規約に従うことを保証する。AIエージェントにDDDルールを明示する手法は、Hexagonal ArchitectureとDDDを組み合わせたコーディングルール設計として複数の実践報告がある。

**強み：** AIが生成するコードの構造的品質を上流から制御できる点。DDDのバウンデッドコンテキストがそのままエージェントの責務境界の定義となり、複数エージェントを導入した際の連携プロトコルとしても機能する。

**弱み：** 単独では「正しいコードを生成する」ことはできても、「正しいコードであることを検証する」フィードバックループを持たない。アーキテクチャルールの違反を事後的に検出する仕組みがなく、手動編集や他のエージェントによる変更でDDD規約が壊れる可能性がある。

### 1.2 Maestro E2Eテストエージェント

MaestroはモバイルUI自動テストフレームワークで、YAML形式のテスト定義が特徴。このYAML形式がAIによるテスト生成と極めて相性が良い。Dartベースの`integration_test`と比較すると、YAMLは宣言的かつ決定論的であり、LLMが有効なテストフローを生成する精度が高い。Maestroの組み込み自動待機・リトライ機構により、AI生成テストのフレイキー（不安定）率も低く抑えられる。

Flutter 3.19以降で追加された`Semantics(identifier: ...)`プロパティにより、表示テキストに依存しない安定的な要素セレクタが利用可能となった。これはローカライゼーションやA/Bテスト環境でのテスト安定性に直結する。

**強み：** YAML形式はLLMにとって最も生成しやすいテスト形式であり、E2Eテストの自動生成に最適。`runFlow`によるネスト構造でモジュラーなテスト設計が可能。`--shards`オプションによる並列実行もサポート。

**弱み：** E2Eテストはテストピラミッドの頂点のみをカバーしており、実行速度が遅く（1フローあたり10〜30秒）、障害箇所の特定精度が低い。Maestroフローが失敗した場合、「何かが壊れた」ことはわかるが「何が壊れたか」の切り分けが困難。

### 1.3 2エージェント構成の構造的課題

現状の構成には3つの構造的欠陥がある。

**テストピラミッドの中間層が空白。** E2Eテストのみでは、ユニットテスト（ドメインロジックの検証）、ウィジェットテスト（UIコンポーネントの視覚的回帰検知）、インテグレーションテスト（ネイティブOS連携の検証）が一切カバーされない。これらの層を埋めるエージェントが必要。

**エージェント間のフィードバックループが存在しない。** DDDアーキテクトがコードを生成し、MaestroエージェントがE2Eテストを生成するが、両者は独立して動作している。テスト失敗時にアーキテクトへ自動で差し戻す仕組みや、TDDのRed → Green → Refactorサイクルを強制するオーケストレーションが欠如している。

**アーキテクチャ違反の事後検出手段がない。** DDDアーキテクトはコード生成時のガイドとして機能するが、レビュー時にレイヤー境界違反を検出するエージェントがなく、アーキテクチャの漸進的劣化（drift）を防止できない。

---

## 2. 追加すべきエージェントの評価

### 2.1 Plannerエージェント（計画策定）

everything-claude-codeリポジトリのPlannerエージェントは、`/plan`コマンドで呼び出され、コード記述前に「要件の再確認 → リスク特定 → フェーズ分割 → ユーザー承認待ち」の4ステップを強制する。承認なしでは絶対にコード生成に進まない設計。ツール権限はReadとGrepのみで、コードを誤って変更するリスクがゼロ。

**評価：導入優先度 最高**

「考えてから書く」をシステム的に保証するこのエージェントは、AIコーディングの最大の落とし穴（即座にコードを書き始めて手戻りする）を構造的に防ぐ。DDDアーキテクトエージェントとの組み合わせでは、Plannerが「どのバウンデッドコンテキストに影響するか」「どのアグリゲートを変更するか」を事前に洗い出し、アーキテクトが「その変更はレイヤー規約に違反しないか」を検証する分担が可能。

ただし、汎用設計のため、Flutter DDD固有の考慮事項が計画に含まれない。以下のようなDDD拡張テンプレートをプロンプトに追加すべきである。

```markdown
## 影響分析
- 変更対象のBounded Context:
- 影響を受けるAggregate/Entity:
- 新規/変更されるDomain Event:
- 必要なValue Object:

## テスト戦略
- Unit Test対象（Domain層）:
- Widget Test対象（Presentation層）:
- Maestro E2Eフロー（ユーザージャーニー）:

## レイヤー別タスク
- Domain層の変更:
- Application層（UseCase）の変更:
- Infrastructure層の変更:
- Presentation層の変更:
```

また、Plannerの出力を自然言語だけでなく構造化データ（JSON/YAML）としても出力させることで、後続エージェントが計画を機械的に参照できるようになる。everything-claude-codeのHandoff Documentsパターン（エージェント間コンテキスト受け渡しドキュメント）がこの発想に近い。

### 2.2 Doc-Updaterエージェント（ドキュメント自動更新）

コード変更に追従してREADME、API仕様、CLAUDE.md等を自動更新するエージェント。Read、Write、Edit、Grep権限を持ち、バックグラウンド実行が可能。

**評価：導入優先度 高**

DDDの最大の実務的課題は「ユビキタス言語の辞書やドメインモデルの図がコードと乖離していく」ことである。Doc-Updaterをフック経由で自動トリガーすれば、エンティティやバリューオブジェクトの変更時にドメインモデルのドキュメントを同期できる。`claude-code-auto-memory`プロジェクトが実装している「dirty-filesキュー → memory-updater agent → CLAUDE.md更新」パターンが参考になる。

バックグラウンド実行（`background: true`）により、メインのオーケストレーターのコンテキストウィンドウを占有しない。

ただし、汎用Doc-Updaterでは「何を更新すべきか」の判断が曖昧なため、Flutter DDD専用のスキル（`skills/flutter-ddd-docs/SKILL.md`）を作成し、以下のようなルールを明文化すべきである。

- `domain/entities/`以下が変更 → ドメインモデルMermaid図を再生成
- `features/`以下に新ディレクトリ追加 → CLAUDE.mdのアーキテクチャ図を更新
- Infrastructure層の実装変更 → リポジトリインターフェース仕様を更新
- Maestroテスト追加/変更 → テストカバレッジマップを更新

### 2.3 Unit Testエージェント（ユニットテスト生成）

**評価：導入優先度 最高**

テストピラミッドの基盤を埋める最重要エージェント。`flutter_test`と`mocktail`を使用し、DDDエンティティ・バリューオブジェクトの仕様からテストを生成する。具体的には、コンストラクタバリデーション、状態遷移、ビジネスルール適用、等価性の検証テストを自動生成する。

状態管理ライブラリ別の対応が必要で、Riverpodの場合は`ProviderContainer.test()`を使ったプロバイダ単体テスト、BLoCの場合は`blocTest<Event, State>`を使ったイベント→状態テストを生成する。

さらに、プロパティベーステストとして`kiri_check`パッケージを活用すれば、ドメイン不変条件からエッジケースを自動生成できる。例えば、EmailバリューオブジェクトのフォーマットルールをそのままforAllプロパティに変換可能。

| テスト層 | ツール | 速度 | 障害特定精度 | AI生成容易度 |
|---------|--------|------|-------------|-------------|
| Unit | flutter_test + mocktail | ミリ秒/テスト | 関数単位で特定 | 高 |
| Widget | golden_toolkit + a11y | 100ms/テスト | 視覚的回帰を特定 | 中 |
| Integration | Patrol + integration_test | 秒/テスト | 機能領域に絞込 | 中 |
| E2E | Maestro YAML | 10-30秒/フロー | ジャーニー単位 | 最高 |

### 2.4 Widget Testエージェント（ウィジェットテスト・ビジュアル回帰テスト）

**評価：導入優先度 高**

Flutterのゴールデンテスト機能と`golden_toolkit`を組み合わせ、全画面・重要コンポーネントの`matchesGoldenFile()`アサーションを生成する。ゴールデンテストでは実フォントを使用し、複数デバイスサイズでのスクリーンショットを生成する。

同時に、Flutterの組み込みアクセシビリティガイドラインAPI（`AccessibilityGuideline`クラス）を活用して、タップターゲットサイズ（Android: 48×48dp以上、iOS: 44×44dp以上）、テキストコントラスト比（4.5:1以上、WCAG AA準拠）、ラベル完全性を自動検証する。`flutter_accessibility_scanner`パッケージはWCAG 2.1スキャン結果をJSON形式で出力可能。

### 2.5 Code Reviewエージェント（コードレビュー・DDD境界チェック）

**評価：導入優先度 最高**

DDDアーキテクチャの漸進的劣化を防ぐ最も重要なエージェント。自然言語でDDD境界ルールを定義し、PR単位で違反を検出する。例えば「Presentation層がInfrastructure層を直接インポートしている場合はフラグ」「Domain層ファイルにFlutterインポートが含まれる場合はリジェクト」等。

外部ツールとしてCodeRabbitとの連携が最も効果的で、月額$12でDart/Flutter固有のセキュリティ脆弱性、パフォーマンスボトルネック、スタイル不整合を検出できる。GitHub Checkとして設定すれば、アーキテクチャ違反PRのマージをブロック可能。

### 2.6 Security Reviewerエージェント（セキュリティスキャン）

**評価：導入優先度 高**

`dart_shield`によるDart固有SAST（ハードコードされたシークレット、弱いハッシュ、安全でないURL）をプリコミットフックで実行し、Snykによる依存関係脆弱性スキャンをCIで実行する。Flutterで特に検出すべき脆弱性は、SharedPreferencesへの機密データ保存、ハードコードされたAPIキー、SSLピンニングの欠如、コード難読化の不足。

### 2.7 ドキュメント生成エージェント（C4図・API仕様）

**評価：導入優先度 中**

C4Diagrammer（MCPサーバー）を使い、ソースコードからC4アーキテクチャ図（Mermaid.js形式）を自動生成する。各ディレクトリレベルでコンテナ図を生成し、ルートではシステムコンテキスト図に集約する。手動C4作成と比較して約88%の精度で、ドキュメント作成サイクルを6〜12時間短縮できるとの報告がある。`dart doc`によるAPI参照ドキュメント生成と組み合わせると効果的。

### 2.8 ローカライゼーションエージェント

**評価：導入優先度 中**

`arb_translate`（LeanCode製）がGoogle GeminiやOpenAIを使って未翻訳ARBエントリを自動翻訳する。より包括的には`flutter_ai_i18n_extractor`がコードベース内のハードコード文字列をスキャンし、ARBファイルへの抽出、意味あるキー生成、10以上のAIプロバイダによるバッチ翻訳を実行可能。ソースロケールファイルの変更トリガーでCIジョブとして実行するのが最適。

---

## 3. エージェント連携アーキテクチャパターン

調査の結果、4つのパターンを特定した。それぞれClaude Codeのsubagent、skill、hookプリミティブの組み合わせが異なる。

### 3.1 パターンA：スキルオーケストレーション型TDDパイプライン

alexop.devのTDDパターンを基にした最も実績のあるアプローチ。単一のClaude Codeスキルが3つの隔離サブエージェントを明示的フェーズで順次実行する。

`.claude/skills/flutter-tdd/SKILL.md`がワークフローを定義する。機能リクエストをトリガーに、DDDアーキテクトサブエージェント（Redフェーズ：失敗するテスト生成）→ 実装サブエージェント（Greenフェーズ：テストを通す最小限のコード）→ リファクタリングサブエージェント → Maestroエージェント（E2Eフロー生成）の順で実行される。各サブエージェントは完全なコンテキスト隔離で動作し、テスト作成者が実装の詳細を知らないため、LLMが「テストに合わせたコード」を生成するチートを防止できる。

```
機能リクエスト
    → [Planner: 計画策定・承認待ち]
    → [DDD Architect: 失敗テスト生成 (Red)]
    → [Implementer: 最小限の実装 (Green)]
    → [Refactorer: リファクタ]
    → [Maestro Agent: E2Eフロー生成]
    → ✅ または差し戻しループ
```

**設定例：**
```yaml
---
name: flutter-tdd
description: Flutter DDD機能のフルTDDサイクル
context: fork
---
$ARGUMENTS の機能実装:
1. PLAN: @plannerを使い実装計画を策定。ユーザー承認を待つ。
2. RED: @ddd-architectを使いドメイン仕様から失敗テストを生成
3. `flutter test`でテスト失敗を確認
4. GREEN: @implementerを使い最小限の実装コードを記述
5. テスト通過を確認
6. REFACTOR: @refactorerを使いクリーンアップ
7. テスト通過を再確認
8. @maestro-e2eを使いE2Eフローを生成
9. `maestro test`でE2E検証
10. @doc-updaterをバックグラウンドで実行しドキュメント同期
現在のフェーズの検証が通過するまで次フェーズに進まないこと。
```

**利点：** hooks併用時に約84%のスキル活性化率が報告されている実証済みパターン。コンテキスト隔離によりLLMのショートカットを防止。明確なフェーズゲート。現行安定版Claude Code機能で動作。

**欠点：** 逐次実行のみで機能間の並列処理不可。サブエージェントが他のサブエージェントを起動できない深度制限。セットアップに約2時間必要。

### 3.2 パターンB：並列エージェントチーム（共有タスクリスト）

Claude Codeの実験的Agent Teams機能を使い、複数のClaudeインスタンスが直接メッセージングで協調する。

チームリーダー（Opusモデル）が機能をDDDドメインモデリング、ウィジェット実装、テスト生成、E2Eフロー作成の並列トラックに分解する。各チームメンバー（Sonnetモデル）が同時に作業し、テストエージェントが実装者に失敗パターンを通知したり、アーキテクトがE2Eエージェントに新画面フローを通知する。

```
[チームリーダー (Opus)] ──→ [DDD Architect (Sonnet)] → ドメインモデル
                       ──→ [Widget Builder (Sonnet)] → UI実装
                       ──→ [Test Agent (Sonnet)]     → ユニット+ウィジェットテスト
                       ──→ [Maestro Agent (Sonnet)]  → E2Eフロー
                            ↕ チームメイト間の直接メッセージング ↕
```

`CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`で有効化。`~/.claude/tasks/`の`blockedBy`フィールドで依存関係を追跡。Opusはリーダーの複雑な推論に、Sonnetはワーカーの実装タスクに使い分けることでコストを最適化。

**利点：** 真の並列処理で開発時間を大幅短縮。直接メッセージングによるリアルタイム協調。モデル混合でコスト最適化。

**欠点：** 実験的機能（v2.1.32+、2026年2月）で不安定性が予想される。複数同時インスタンスによるAPIコスト増。エージェント間の競合変更時のデバッグが複雑。gitワークツリー等のファイル分離が必要。

### 3.3 パターンC：フック駆動イベントバス

Claude Codeのフックシステムを決定論的イベントバスとして使い、各エージェントが特定のファイルシステム/ツールイベントに反応する。

DDDアーキテクトが新エンティティファイルを書き込むと（`PostToolUse` on `Write` matching `*/domain/entities/*.dart`）、フックが自動でユニットテストエージェントをトリガー。テストファイル書き込み時は別のフックが`flutter test`をトリガー。実装ファイル変更時はコードレビューエージェントがトリガーされる。

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write",
        "hooks": [{
          "type": "command",
          "command": "if echo \"$TOOL_INPUT\" | grep -q 'domain/entities'; then claude -p 'エンティティのユニットテスト生成' --allowedTools Read,Write; fi"
        }]
      },
      {
        "matcher": "Edit|Write",
        "hooks": [{
          "type": "command",
          "command": "cd $PROJECT_ROOT && flutter test --reporter json 2>&1 | tail -1"
        }]
      }
    ]
  }
}
```

**利点：** 決定論的（フックは必ず発火し、プロンプトベースのスキル呼び出しのようにLLMの判断に依存しない）。構成可能（既存フックを変更せずにフック追加で新エージェントを導入可能）。単純な検証（lint、format、test）の低レイテンシ。安定版Claude Code機能で動作。DDD境界の自然な強制ポイント。

**欠点：** JSONの中のシェルスクリプトが脆弱でデバッグ困難。ファイルシステム以外のエージェント間状態共有が不可。多段ワークフロー（TDDサイクル）をイベントだけで実装するのが困難。フックタイムアウト（デフォルト10分）による複雑なエージェント作業の制限。フックチェーンのカスケードリスク。

### 3.4 パターンD：ハイブリッドオーケストレーター＋CI/CD統合

パターンAのスキルオーケストレーター（インタラクティブ開発用）とパターンCのフック駆動CIエージェント（自動品質ゲート用）を組み合わせ、さらにGitHub ActionsでMaestro E2Eレイヤーを統合する。

**開発時：** TDDスキルで機能作業を行い、フックが即時フィードバック（フォーマット、リンティング、影響テスト実行）を処理。DDDアーキテクトがドメインモデルを生成し、テストエージェントがTDDサイクル内でユニット/ウィジェットテストを生成。

**CI時：** PR作成トリガーで`anthropics/claude-code-action@v1`がDDD境界チェック付きコードレビューを実行。別ジョブでMaestro E2Eスイートを実行。夜間スケジュールジョブでClaude Codeヘッドレスモードによるテストカバレッジ不足の自動補完とPR作成。

```
開発マシン:
  [Planner] → [TDD Skill] → [DDD Architect] → [Test Agent] → [Refactorer]
  [Hooks] → 保存時自動format、自動lint、自動test
  [Doc-Updater] → バックグラウンドでドキュメント同期

GitHub CI:
  [PRトリガー] → [Code Review Agent] → [Security Scan] → [Maestro E2E Suite]
  [夜間] → [Coverage Agent] → 未カバーテスト自動生成 → PR作成
  [週次] → [Dependency Agent] → 安全な依存更新 → PR作成
```

**利点：** 高速なインタラクティブフィードバックと包括的CIゲートの両立。チーム開発にスケール（CIエージェントが全開発者のPRに適用）。夜間テスト生成で継続的カバレッジ改善。開発時とCI時のエージェント分離によるコスト削減。

**欠点：** セットアップと保守が最も複雑。GitHub Actions設定、APIキー管理、CIランナープロビジョニングが必要。夜間ジョブの継続的APIコスト。ローカルとCIのエージェント設定の乖離リスク。

### 推奨選択

**即座の生産性向上にはパターンAから開始。** チームとCIインフラの成熟に伴い**パターンDに移行。** Agent Teamsが安定した後に**パターンBの採用を検討。**

---

## 4. DDDドメインモデルからのテスト自動生成

DDD仕様をテスト生成の契約として使う、最もレバレッジの高いパターンについて詳述する。

### 4.1 ドメイン不変条件 → プロパティベーステスト

エンティティの不変条件はプロパティベーステストに直接変換できる。`Order`アグリゲートが「合計は明細合計と一致」「ステータス遷移はdraft → confirmed → shipped → deliveredの順」と定義していれば、AIエージェントが`kiri_check`のforAllプロパティとして、これらの不変条件をランダム入力に対してテストするコードを生成する。バリューオブジェクトの検証ルール（Emailフォーマット、Price非負）も境界条件を網羅的にテストするforAllジェネレーターになる。

### 4.2 ドメインイベント → E2Eテストチェックポイント

ドメインイベントはMaestroフローのチェックポイントにマッピングできる。`OrderConfirmed`イベントは確認画面の表示と正しい注文情報の検証をトリガーし、`PaymentProcessed`イベントは決済成功フローの検証をトリガーする。Event Stormingの成果物があれば、E2Eテストがカバーすべき完全なユーザージャーニーマップを提供する。

### 4.3 BDD Gherkinブリッジ

`bdd_widget_test`パッケージが`.feature`ファイルからFlutterウィジェットテストを生成する。DDDのユビキタス言語辞書を読み取るAIエージェントがGherkinシナリオを生成できる。

```gherkin
Feature: 注文チェックアウト
  Scenario: 確定注文が正しい合計を表示
    Given カートに合計¥4,599の3商品がある
    When 注文を確定する
    Then 合計"¥4,599"の注文確認画面が表示される
    And 注文ステータスが"確定済み"と表示される
```

LLM生成Gherkinに関する研究（SBC, 2025）では、GPT-4 TurboとGeminiがゼロショットプロンプトでもfew-shotに匹敵する品質を生成できると報告されており、セットアップ工数が最小限で済む。品質の鍵はドメイン言語ガイドラインの提供であり、DDDアーキテクトが既に管理しているユビキタス言語辞書がそのまま使える。

---

## 5. 推奨エージェント構成と統合ワークフロー

全調査結果を統合した推奨エージェント構成を以下に示す。

### 5.1 エージェント一覧（優先度順）

```
~/.claude/agents/
├── planner.md              # 計画策定・DDD影響分析（優先度：最高）
├── ddd-architect.md        # DDDドメインモデル・レイヤー別コード生成（既存）
├── unit-test-agent.md      # ユニットテスト生成（優先度：最高）
├── code-reviewer.md        # DDD境界チェック・コードレビュー（優先度：最高）
├── widget-test-agent.md    # ゴールデンテスト・a11y検証（優先度：高）
├── maestro-e2e.md          # E2Eテストフロー生成（既存）
├── doc-updater.md          # ドキュメント自動同期（優先度：高）
├── security-reviewer.md    # セキュリティスキャン（優先度：高）
├── refactor-cleaner.md     # リファクタリング・デッドコード除去（優先度：中）
└── l10n-agent.md           # ローカライゼーション自動翻訳（優先度：中）
```

### 5.2 統合ワークフロー

```
ユーザー: /plan "注文確認画面を追加"
    │
    ▼
[Planner Agent] ← DDD拡張テンプレート付き
    │  要件再確認 + 影響Aggregate特定 + テスト戦略 + フェーズ分割
    │  → 構造化出力（JSON/YAML） → Handoff Document生成
    │  → ユーザー承認待ち ✋
    ▼
[DDD Architect Agent]
    │  ドメインモデル生成（Entity/VO/Event）
    │  レイヤー別コード生成（Domain → Application → Infrastructure → Presentation）
    ▼
[Unit Test Agent] + [Widget Test Agent]  ← 並列実行可能
    │  Plannerの計画からテスト対象を特定
    │  ドメイン不変条件 → プロパティベーステスト
    │  画面コンポーネント → ゴールデンテスト + a11y検証
    ▼
[Maestro E2E Agent]
    │  ドメインイベント列 → ユーザージャーニーYAMLフロー
    │  Semantics(identifier:) ベースの安定セレクタ
    ▼
[Doc-Updater Agent] ← バックグラウンド自動トリガー（PostToolUseフック）
    │  ドメインモデルMermaid図更新
    │  CLAUDE.mdアーキテクチャセクション更新
    │  テストカバレッジマップ更新
    ▼
[Code Review Agent]
    │  DDD境界違反チェック
    │  ドキュメント整合性チェック
    │  → 問題あり: Plannerに差し戻し
    │  → 問題なし: ✅ 完了
```

### 5.3 実装の第一歩

最速で動くマルチエージェントシステムの構築に必要なファイルは3つ。

**CLAUDE.md：** DDDルール、プロジェクト構造、エージェントチーム構成を符号化する。明示的な依存方向ルール（「ドメイン層はFlutterインポートを含まない純粋Dartであること」）、命名規約、状態管理パターンを含める。

**`.claude/settings.json`：** 決定論的品質ゲートのフック設定。必須フック：Dartファイルの`Write|Edit`時に`dart analyze`と`flutter test`をトリガーする`PostToolUse`。危険コマンドをブロックする`PreToolUse`。サブエージェント完了時の進捗監視用`SubagentStop`。

**`.claude/skills/flutter-tdd/SKILL.md`：** DDDアーキテクトとテストエージェントをサブエージェントとして参照するTDDオーケストレータースキル。明示的フェーズゲート（「テスト失敗確認までGreenフェーズに進まない」）を含め、LLMが検証をスキップすることを防止。`context: fork`で隔離実行。

---

## 6. 核心的知見

**DDDは単なるアーキテクチャパターンではなく、AIエージェント連携プロトコルである。** バウンデッドコンテキストはエージェントの責務境界を定義し、ユビキタス言語はエージェント間の共有語彙を提供し、ドメインイベントは生成・テスト・検証エージェントを接続するイベントバスを形成する。AI支援開発で最良の結果を出しているチームは、AIでコードを速く書いているのではなく、DDDでAIエージェントを合成可能にしている。
